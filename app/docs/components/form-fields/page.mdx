---
asIndexPage: true
sidebarTitle: FormField
---

# FormField

FormField is a modular, type-safe form-field system built with **React Hook Form**, **TypeScript**, and **Material-UI**. It turns each input type into a small, focused component so large, form-heavy apps stay maintainable and predictable. You get strict types (no `any`), tiny well-documented components, and a single predictable integration pattern so teams can add 20–30+ field types without the UI becoming a tangle.

---

# Why use this system

This system solves the repeated work that comes with forms:

- each field is its own component so behavior, validation, and rendering are isolated;
- everything is typed end-to-end (default shapes → form values → components);
- components are already wired to `react-hook-form`’s `Controller` so you avoid repeated boilerplate;
- defaults and patterns keep UI consistent across pages.

In short: fewer bugs, faster onboarding, and easier tests.

---

# Core idea (how it works)

---

asIndexPage: true
sidebarTitle: Built-In Components
icon: BoxIcon

---

1. A tiny **router component** (`FormField.tsx`) picks the right field component by `type` and forwards props.
2. Each field component (text, number, select, date, etc.) is responsible only for rendering + minimal conversion logic (string ↔ number, iso date ↔ Date, counters, helper text).
3. Types live in a single `types.ts` so adding a new field requires: add component, extend types, register in router — predictable and small steps.
4. Use `FormProvider` to share the form `control` and other common helpers; components will use `useFormContext` by default but accept a `control` prop for explicit wiring.

---

# Folder structure (recommended)

```
components/
└── form/
    ├── index.ts            # barrel exports
    ├── FormField.tsx       # router component
    ├── types.ts            # shared types
    └── fields/
        ├── FormTextField.tsx
        ├── FormNumberField.tsx
        └── ...other fields
```

---

# Key files (concise, copy-ready)

### Router — `FormField.tsx`

```tsx
import type { FormFieldProps } from "./types";
import FormTextField from "./fields/FormTextField";
import FormNumberField from "./fields/FormNumberField";

export default function FormField(props: FormFieldProps) {
  switch (props.type) {
    case "text":
      return <FormTextField {...props} />;
    case "number":
      return <FormNumberField {...props} />;
    default:
      return null;
  }
}
```

### Types — `types.ts`

```ts
import type { Control, RegisterOptions } from "react-hook-form";
import type { GridBaseProps } from "@mui/material/Grid";

export type BaseFieldProps = {
  name: string;
  label?: string;
  fullWidth?: boolean;
  required?: boolean;
  placeholder?: string;
  helpingText?: string;
  rules?: RegisterOptions;
  control?: Control<any>;
  grid?: GridBaseProps;
};

export type FormFieldProps =
  | ({ type: "text" } & BaseFieldProps & {
        maxLength?: number;
        fieldProps?: any;
      })
  | ({ type: "number" } & BaseFieldProps & {
        maxLength?: number;
        fieldProps?: any;
      });
```

### Text field — `FormTextField.tsx`

```tsx
import { Controller, useFormContext } from "react-hook-form";
import TextField from "@mui/material/TextField";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import type { FormTextFieldProps } from "../types"; // adjust import as needed

export default function FormTextField(props: FormTextFieldProps) {
  const { control } = useFormContext();
  const fullWidth = props.fullWidth ?? true;

  return (
    <Controller
      name={props.name}
      rules={props.rules}
      control={props.control ?? control}
      render={({ field, fieldState }) => {
        const value = field.value ?? "";
        const showCounter = typeof props.maxLength === "number";
        return (
          <TextField
            {...field}
            {...props.fieldProps}
            label={props.label}
            fullWidth={fullWidth}
            placeholder={props.placeholder}
            required={props.required}
            error={!!fieldState.error}
            onChange={(e) => field.onChange(e.target.value.trimStart())}
            inputProps={{ maxLength: props.maxLength }}
            helperText={
              <Box sx={{ display: "flex", justifyContent: "space-between" }}>
                <Typography variant="caption">
                  {fieldState.error?.message || props.helpingText}
                </Typography>
                {showCounter && (
                  <Typography variant="caption">
                    {String(value).length} / {props.maxLength}
                  </Typography>
                )}
              </Box>
            }
          />
        );
      }}
    />
  );
}
```

### Number field — `FormNumberField.tsx`

```tsx
import { Controller, useFormContext } from "react-hook-form";
import TextField from "@mui/material/TextField";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import type { NumberFieldProps } from "../types";

export default function FormNumberField(props: NumberFieldProps) {
  const { control } = useFormContext();
  const fullWidth = props.fullWidth ?? true;

  return (
    <Controller
      name={props.name}
      rules={props.rules}
      control={props.control ?? control}
      render={({ field, fieldState }) => {
        const valueString = String(field.value ?? "");
        const showCounter = typeof props.maxLength === "number";

        return (
          <TextField
            {...field}
            {...props.fieldProps}
            fullWidth={fullWidth}
            type="number"
            label={props.label}
            required={props.required}
            error={!!fieldState.error}
            placeholder={props.placeholder}
            onChange={(e) => {
              const raw = e.target.value;
              field.onChange(raw === "" ? "" : Number(raw));
            }}
            inputProps={{ inputMode: "numeric", maxLength: props.maxLength }}
            helperText={
              <Box sx={{ display: "flex", justifyContent: "space-between" }}>
                <Typography variant="caption">
                  {fieldState.error?.message || props.helpingText}
                </Typography>
                {showCounter && (
                  <Typography variant="caption">
                    {valueString.length} / {props.maxLength}
                  </Typography>
                )}
              </Box>
            }
          />
        );
      }}
    />
  );
}
```

---

# How to use (step-by-step)

1. Install dependencies:

   ```bash
   pnpm add react-hook-form @mui/material @emotion/react @emotion/styled
   ```

2. Wrap your form with `FormProvider` (from `react-hook-form`) so field components can use `useFormContext`.
3. Use `FormField` in the form and pass `type`, `name`, and other base props.
4. If you need a field to be controlled by another provider or have an isolated `control`, pass a `control` prop to the field.

Example:

```tsx
import { useForm, FormProvider } from "react-hook-form";
import FormField from "@/components/form/FormField";

export default function DemoForm() {
  const methods = useForm({ defaultValues: { username: "", age: 0 } });
  const onSubmit = methods.handleSubmit(console.log);

  return (
    <FormProvider {...methods}>
      <form onSubmit={onSubmit}>
        <FormField type="text" name="username" label="Full Name" required />
        <FormField type="number" name="age" label="Age" required />
        <button type="submit">Submit</button>
      </form>
    </FormProvider>
  );
}
```

---

# Best practices & patterns

- Keep each field component focused: rendering + lightweight type conversion + display helpers (counters, helper text).
- Prefer `useFormContext` inside fields and expose an optional `control` prop for advanced cases.
- Put validation rules in page-level code (or a small validators module) and pass them as `rules` to keep components dumb.
- Keep UI logic (error layout, helper text) consistent across fields — copy the helper block pattern.
- Test behavior, not markup: assert validation and user flows.

---

# Extending the system

To add a new field:

1. Create `fields/SelectField.tsx` (or `DateField.tsx`, etc.) — small component using `Controller`.
2. Add its type to `types.ts`.
3. Register it in `FormField.tsx`.
4. Add a Storybook story and one behavior test.

That pattern guarantees every new field fits the same runtime and test shape.
