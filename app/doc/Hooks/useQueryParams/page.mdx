import { Steps } from "nextra/components";

# useQueryParams

A lightweight, type-safe React hook for managing URL query parameters with support for **nested objects**, **arrays**, **dates**, **numbers**, **booleans**, and **strings** ‚Äî built on top of `react-router-dom`'s `useSearchParams`.

## Why `useQueryParams`?

- Eliminates manual `URLSearchParams` parsing.
- Handles multiple data types safely.
- Automatically keeps URLs clean (removes values matching defaults).
- Supports nested objects out of the box.
- Includes per-key setters for high-performance updates.
- Works seamlessly with React Router v6+.

## üì¶ Installation

<Steps>

### Install `react-router-dom`

```bash
npm install react-router-dom
# or
yarn add react-router-dom
```

### Add the useQueryParams hook to your project

Create a file:

```bash
src/hooks/useQueryParams.ts
```

### Paste this code inside:

```tsx filename="useQueryParams.tsx" copy showLineNumbers
import { useSearchParams, type NavigateOptions } from "react-router-dom";
import { useMemo, useRef, useCallback } from "react";

// --------------------
// Helpers: flatten / unflatten
// --------------------
function flatten(
  obj: Record<string, any>,
  prefix = "",
  res: Record<string, any> = {}
) {
  for (const key in obj) {
    const val = obj[key];
    const path = prefix ? `${prefix}.${key}` : key;

    if (
      val &&
      typeof val === "object" &&
      !Array.isArray(val) &&
      !(val instanceof Date)
    ) {
      flatten(val, path, res);
    } else {
      res[path] = val;
    }
  }
  return res;
}

function unflatten(flat: Record<string, any>) {
  const result: Record<string, any> = {};
  for (const path in flat) {
    const keys = path.split(".");
    let cur = result;
    keys.slice(0, -1).forEach((k) => {
      if (!cur[k]) cur[k] = {};
      cur = cur[k];
    });
    cur[keys[keys.length - 1]] = flat[path];
  }
  return result;
}

// --------------------
// Helpers: parse / serialize
// --------------------
function parseValue(raw: string | null, def: any) {
  if (raw == null) return def;

  if (Array.isArray(def)) {
    if (!raw) return def;
    const parts = decodeURIComponent(raw).split(",");
    const elemDef = def[0] ?? "";
    return parts.map((v) => parseValue(v, elemDef));
  }

  if (def instanceof Date) {
    const d = new Date(raw);
    return isNaN(d.getTime()) ? def : d;
  }
  if (typeof def === "number") {
    const n = Number(raw);
    return isNaN(n) ? def : n;
  }
  if (typeof def === "boolean") return raw === "true";
  return raw;
}

function serializeValue(value: any) {
  if (Array.isArray(value))
    return encodeURIComponent(value.map(String).join(","));
  if (value instanceof Date) return encodeURIComponent(value.toISOString());
  return encodeURIComponent(String(value));
}

function isEqual(a: any, b: any) {
  if (Array.isArray(a) && Array.isArray(b))
    return a.length === b.length && a.every((v, i) => isEqual(v, b[i]));
  if (a instanceof Date && b instanceof Date)
    return a.getTime() === b.getTime();
  return String(a) === String(b);
}

// --------------------
// Hook: useQueryParams
// --------------------
export function useQueryParams<T extends Record<string, any>>(defaults: T) {
  const [params, setParams] = useSearchParams();
  const defaultsRef = useRef(flatten(defaults));

  // Get current flat values
  const flatValues = useMemo(() => {
    const out: Record<string, any> = {};
    for (const key in defaultsRef.current) {
      out[key] = parseValue(params.get(key), defaultsRef.current[key]);
    }
    return out;
  }, [params]);

  const values = useMemo(() => unflatten(flatValues) as T, [flatValues]);

  // Update multiple keys
  const set = useCallback(
    (updates: Partial<T>, nav?: NavigateOptions) => {
      const flat = flatten(updates);
      setParams((prev) => {
        const next = new URLSearchParams(prev.toString());
        for (const key in flat) {
          const val = flat[key];
          const def = defaultsRef.current[key];
          if (val == null || isEqual(val, def)) next.delete(key);
          else next.set(key, serializeValue(val));
        }
        return next;
      }, nav);
    },
    [setParams]
  );

  // Per-key setter
  const key = useCallback(
    (path: string) => ({
      value: flatValues[path] ?? defaultsRef.current[path],
      set: (v: any, nav?: NavigateOptions) => {
        setParams((prev) => {
          const next = new URLSearchParams(prev.toString());
          const def = defaultsRef.current[path];
          if (v == null || isEqual(v, def)) next.delete(path);
          else next.set(path, serializeValue(v));
          return next;
        }, nav);
      },
    }),
    [flatValues, setParams]
  );

  // Reset to defaults
  const reset = useCallback(
    (nav?: NavigateOptions) => {
      setParams(() => {
        const next = new URLSearchParams();
        for (const key in defaultsRef.current) {
          const def = defaultsRef.current[key];
          if (def != null && !(Array.isArray(def) && def.length === 0)) {
            next.set(key, serializeValue(def));
          }
        }
        return next;
      }, nav);
    },
    [setParams]
  );

  return { values, set, key, reset } as const;
}
```

</Steps>

## üß© API Overview

#### @values

The parsed query parameters returned as your typed object.

#### @set(updates, options?)

Update multiple parameters at once. Automatically removes keys matching defaults.

#### @key(path)

Returns `key` and `set` for a specific parameter.
Best for input fields or isolated updates.

#### @reset(options?)

Resets all parameters to their default values.

## üìò Usage Examples

### 1. Basic Example

```tsx filename="Products.tsx" showLineNumbers
import { useQueryParams } from "./hooks/useQueryParams";

type Filters = {
  search: string;
  page: number;
  tags: string[];
  date: Date | null;
};

const defaultFilters: Filters = {
  search: "",
  page: 1,
  tags: [],
  date: null,
};

export const Products = () => {
  const { values, set, key, reset } = useQueryParams(defaultFilters);

  return (
    <div>
      <input
        value={values.search}
        onChange={(e) => set({ search: e.target.value })}
        placeholder="Search products..."
      />

      <button onClick={reset}>Reset Filters</button>

      <pre>{JSON.stringify(values, null, 2)}</pre>
    </div>
  );
};
```

### 2. Per-Key Setter (Recommended for inputs)

```tsx showLineNumbers
const searchParam = key("search");

<input
  value={searchParam.value}
  onChange={(e) => searchParam.set(e.target.value)}
  placeholder="Search products..."
/>;
```

This avoids re-flattening the entire object and makes updates more efficient.

### 3. Updating Multiple Params

```tsx showLineNumbers
set({
  page: 2,
  tags: ["electronics", "gaming"],
});
```

The URL becomes: `?page=2&tags=electronics,gaming`

### 4. Resetting All Params

```tsx showLineNumbers
reset();
```

Resets URL to defaults and ensures a predictable baseline.

## üìå Best Practices

1. **Keep defaults simple**

   Defaults define the ‚Äúclean URL‚Äù baseline.

2. **Use per-key setter for inputs**

   This avoids unnecessary re-renders.

3. **Use as few query params as possible**

   Browsers start struggling beyond ~2000 chars in a URL.

4. **Avoid storing large objects**
   Flattening helps, but URLs shouldn't store:
   - rich text
   - large JSON
   - binary data

## ‚ö†Ô∏è Common Pitfalls & Notes

1. **Arrays must use the same type**

   `tags: ["a"]` ‚Üí OK
   `tags: ["a", 2]` ‚Üí ‚ùå

2. **Empty arrays are removed from URL**

   Because they match default (`[]`).

3. **Dates must be valid**

   Invalid dates fall back to the default.

4. **Nested objects must have stable structure**

   Changing default shape changes URL structure.
